java使用被称为垃圾收集器的技术来监视java程序的运行，当对象不再使用时就自动释放对象所占用的内存。java使用一系列的软指针来跟踪对象的每个引用，并用一个对象表将这些软指针映射为对象的引用。

垃圾收集器是自动运行的，一般情况下，无须显式地请求垃圾收集器。调用System类中的静态gc()方法可以运行垃圾收集器，但这样并不能保证立即回收指定的对象。

java的内存管理就是对象的分配和释放问题。在java中，程序需要用new关键字来为每个对象申请内存空间，所有的对象都在堆中分配空间。另外，对象的释放是由gc决定和执行的，当某个对象不再存在引用时，就满足了释放对象的条件，但满足条件并不一定会立刻释放对象，何时释放是未知的，程序可以调用System.gc()来建议垃圾收集器运行，但无法强制其运行。

在java 中，内存泄露是指存在一些被分配的对象，这些对象满足两个条件：1.对象是可达的，即存在对对象的引用未释放；2.对象是无用的，即程序以后都不会使用这些对象。这些对象不会被gc所回收，而他们却占用内存。
忘记释放先前分配的内存，就可能造成内存泄露

clone方法是在Object中定义的，而且是protected型的，只有实现Cloneable接口，才能调用这个方法，否则会抛出CloneNotSupportException。Object中默认实现的clone是浅复制，即假设对象中的存在非基本类型的变量，使用默认克隆时克隆出来的新变量和原来的变量指向同一个变量，这时候就需要对clone方法进行重写，在方法中对非基本类型的变量进行特殊处理
