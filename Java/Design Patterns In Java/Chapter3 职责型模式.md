### 8.单例模式
将责任集中到某个类的单个实例中( 只有静态方法而无实例方法的不是单例类 )

例如, 通常情况下需要的一个唯一的工厂类

单例模式的意图是为了确保一个类有且仅有一个实例, 并为它提供一个全局访问点

### 9.观察者模式
将对象从依赖于它的对象中解耦

观察者模式的意图是在多个对象之间定义一对多的依赖关系, 当一个对象的状态发生改变时, 会通知依赖于它的对象, 并根据新状态做出相应的反应

1.观察者的实现类必须注册它们感兴趣的对象, 并且自身能做出相应的变更
2.当被观察者的实现类的值发生改变时, 必须记得通知观察者


### 10.调停者模式
将职责集中到某个类, 该类可以监督其他对象的交互
 
调停者模式的意图是定义一个对象, 封装一组对象的交互, 从而降低对象间的耦合度, 避免了对象间的显示引用, 并且可以独立地改变对象的行为

调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。

比如: 主板-调停者, CPU-同事, 内存-同事, 磁盘-同事


### 11.代理模式
让一个对象扮演其他对象的行为

代理模式的意图是通过提供一个代理或者占位符来控制对该对象的访问 (使用代理模式的设计有时候非常脆弱, 因为它依赖于将方法调用转发给底层对象, 这种转发机制可能会创建难以维护的脆弱设计)

范例:如何避免将较大的图像加载到内存中

静态代理模式其实很常见，比如买火车票这件小事：黄牛相当于是火车站的代理，我们可以通过黄牛买票，但只能去火车站进行改签和退票。在代码实现中相当于为一个委托对象realSubject提供一个代理对象proxy，通过proxy可以调用realSubject的部分功能，并添加一些额外的业务处理，同时可以屏蔽realSubject中未开放的接口


### 12.职责链模式
允许将请求传递给职责链的其他对象, 直到这个请求被某个对象处理

职责链模式的目的是通过给予多个对象处理请求的机会, 以解除请求的发送者和接收者之间的耦合

职责链模式的意图在于减轻调用者的压力, 使它们无需了解哪个对象可以处理调用请求

例如:java中的throw , java把exception一级级往上抛, 直到最后遇到一个处理这个exception的类

### 13.享元模式
将共享的, 细粒度的对象职责集中管理

享元模式的意图是通过共享来有效地支持大量细粒度的对象

当你需要管理成千上万的小对象时, 例如电子书中的字符对象, 在这个场景下, 出于性能的考虑,  需要在不同的客户对象间传输浙西细粒度的对象

不变性: 享元模式让多个客户对象间共享访问限定数量的对象, 为了保证对象间不会相互影响, 应该将共享对象设置为不变类型的
